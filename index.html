<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tae-Young Han | AI Media Art Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        /* 기본 설정 */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Noto Sans KR', sans-serif;
        }

        /* p5.js 캔버스 배경 */
        #bg-canvas {
            position: fixed;
            top: 0; left: 0;
            z-index: -1;
        }

        /* 메인 콘텐츠 컨테이너 */
        .container {
            position: relative;
            z-index: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            /* 배경이 잘 보이도록 유리 질감 투명도 조절 */
            background: rgba(15, 12, 41, 0.2);
            backdrop-filter: blur(3px);
            box-shadow: inset 0 0 100px rgba(123, 31, 162, 0.1);
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            margin-bottom: 0.5rem;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #ff00cc, #3333ff, #00dbde);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(187, 0, 255, 0.5), 0 0 40px rgba(0, 0, 255, 0.3);
            animation: titleGlow 3s infinite alternate;
        }

        @keyframes titleGlow {
            from { filter: brightness(1); scale: 1; }
            to { filter: brightness(1.3); scale: 1.02; }
        }

        p.subtitle {
            font-size: 1.2rem;
            color: #b39ddb;
            margin-bottom: 4rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .btn-group { display: flex; gap: 25px; }

        .btn {
            position: relative;
            text-decoration: none;
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: white;
            border-radius: 50px;
            overflow: hidden;
            transition: 0.3s all ease;
            background: linear-gradient(45deg, #6a11cb, #2575fc);
            box-shadow: 0 0 20px rgba(123, 31, 162, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn.secondary {
            background: linear-gradient(45deg, #b721ff, #21d4fd);
            box-shadow: 0 0 20px rgba(183, 33, 255, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 40px rgba(123, 31, 162, 0.8), 0 0 80px rgba(37, 117, 252, 0.4);
            letter-spacing: 2px;
        }
        .btn.secondary:hover {
            box-shadow: 0 0 40px rgba(183, 33, 255, 0.8), 0 0 80px rgba(33, 212, 253, 0.4);
        }

        .btn::before {
            content: '';
            position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: 0.5s;
        }
        .btn:hover::before { left: 100%; }

        footer {
            position: absolute; bottom: 20px; font-size: 0.8rem; color: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div id="bg-canvas"></div>

    <div class="container">
        <h1>p5.js<br>Taeyoung portfolio</h1>
        <p class="subtitle">SSU Global Media | Interactive Portfolio</p>
        
        <div class="btn-group">
            <a href="work1.html" class="btn">PROJECTS 1 & 4</a>
            <a href="work2.html" class="btn secondary">PROJECTS 2 & 3</a>
        </div>
        
        <footer>2025 P5.js_비주얼포트폴리오 최종 과제 (20241865 한태영)</footer>
    </div>

    <script>
        // --- 전역 변수 선언 ---
        let particles = []; // 기존 네트워크 파티클
        const numParticles = 100;

        let stars = []; // 배경 별
        const numStars = 400;

        let shootingStars = []; // 별똥별

        let nebulaNoiseScale = 0.002; // 성운 노이즈 스케일
        let nebulaTime = 0; // 성운 움직임 시간

        let blackHole; // 블랙홀 객체
        let planets = []; // 행성 객체들

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent('bg-canvas');
            
            // 1. 별 초기화
            for (let i = 0; i < numStars; i++) {
                stars.push(new Star());
            }

            // 2. 기존 네트워크 파티클 초기화
            for (let i = 0; i < numParticles; i++) {
                particles.push(new Particle());
            }

            // 3. 블랙홀 및 행성 초기화
            blackHole = new BlackHole(width / 2 + 100, height / 2 - 50);
            planets.push(new Planet(width * 0.2, height * 0.3, 30, color(100, 100, 255), 0.2)); // 파란 행성
            planets.push(new Planet(width * 0.8, height * 0.7, 45, color(255, 150, 100), 0.15)); // 주황 행성
        }

        function draw() {
            // 배경을 완전히 지우지 않고 어둡게 덮어서 잔상 효과 유지
            background(5, 5, 20, 40); // 아주 깊은 우주색

            // --- 레이어 1: 성운 (Nebula) ---
            drawNebula();

            // --- 레이어 2: 별 (Stars) ---
            for (let star of stars) {
                star.update();
                star.draw();
            }

            // --- 레이어 3: 우주 오브젝트 (행성, 블랙홀) ---
            for (let planet of planets) {
                planet.update();
                planet.draw();
            }
            blackHole.draw();

            // --- 레이어 4: 별똥별 (Shooting Stars) ---
            // 가끔씩 별똥별 생성 (1% 확률)
            if (random(1) < 0.01) {
                shootingStars.push(new ShootingStar());
            }
            // 별똥별 업데이트 및 그리기 (화면 밖으로 나가면 삭제)
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                shootingStars[i].update();
                shootingStars[i].draw();
                if (shootingStars[i].isDead()) {
                    shootingStars.splice(i, 1);
                }
            }

            // --- 레이어 5 (가장 앞): 기존 AI 네트워크 파티클 ---
            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                particles[i].draw();
                particles[i].connect(particles.slice(i + 1));
            }
            
            nebulaTime += 0.005; // 성운 시간 흐름
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            blackHole.pos.set(width/2 + 100, height/2 - 50); // 리사이즈 시 블랙홀 위치 재조정
        }

        // ================= 클래스 및 함수 정의 =================

        // --- 성운 그리기 함수 ---
        function drawNebula() {
            noStroke();
            for (let x = 0; x < width; x += 30) {
                for (let y = 0; y < height; y += 30) {
                    // Perlin Noise로 구름 같은 패턴 생성
                    let n = noise(x * nebulaNoiseScale, y * nebulaNoiseScale, nebulaTime);
                    // 노이즈 값에 따라 보라색/파란색 계열의 투명한 원 그리기
                    let r = map(n, 0, 1, 50, 150);
                    let g = map(n, 0, 1, 0, 50);
                    let b = map(n, 0, 1, 100, 255);
                    let alpha = map(n, 0.3, 0.7, 0, 40); // 특정 범위에서만 보이게
                    fill(r, g, b, alpha);
                    ellipse(x, y, 60, 60);
                }
            }
        }

        // --- 별 클래스 ---
        class Star {
            constructor() {
                this.pos = createVector(random(width), random(height));
                this.size = random(0.5, 2.5);
                this.brightness = random(100, 255);
                this.twinkleSpeed = random(0.02, 0.05);
                this.vel = createVector(random(-0.2, 0.2), random(-0.1, 0.1)); // 아주 느리게 움직임
            }
            update() {
                this.pos.add(this.vel);
                // 화면 밖으로 나가면 반대편으로 (토러스)
                if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.x > width) this.pos.x = 0;
                if (this.pos.y < 0) this.pos.y = height;
                if (this.pos.y > height) this.pos.y = 0;
                // 반짝임 효과 using sin()
                this.brightness = map(sin(frameCount * this.twinkleSpeed), -1, 1, 100, 255);
            }
            draw() {
                noStroke();
                fill(255, this.brightness);
                ellipse(this.pos.x, this.pos.y, this.size);
            }
        }

        // --- 별똥별 클래스 ---
        class ShootingStar {
            constructor() {
                this.pos = createVector(random(width), random(height/2)); // 상단 절반에서 시작
                this.vel = createVector(random(-5, -10), random(2, 5)); // 왼쪽 아래로 빠르게
                this.size = random(2, 4);
                this.history = []; // 꼬리 잔상 저장
            }
            update() {
                this.history.push(this.pos.copy()); // 현재 위치 저장
                if (this.history.length > 15) this.history.shift(); // 꼬리 길이 제한
                this.pos.add(this.vel);
            }
            draw() {
                noStroke();
                // 꼬리 그리기
                for (let i = 0; i < this.history.length; i++) {
                    let pos = this.history[i];
                    let alpha = map(i, 0, this.history.length, 0, 255); // 꼬리 끝으로 갈수록 투명
                    fill(200, 200, 255, alpha);
                    ellipse(pos.x, pos.y, map(i, 0, this.history.length, 0.5, this.size));
                }
                // 머리 그리기
                fill(255);
                ellipse(this.pos.x, this.pos.y, this.size + 1);
                // 빛나는 효과
                fill(255, 255, 255, 100);
                ellipse(this.pos.x, this.pos.y, this.size * 4);
            }
            isDead() {
                 return (this.pos.x < -50 || this.pos.y > height + 50); // 화면 밖으로 나가면 사망
            }
        }

        // --- 블랙홀 클래스 ---
        class BlackHole {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.size = 80;
            }
            draw() {
                // 강착원반 (Accretion Disk) - 회전하는 빛무리
                push();
                translate(this.pos.x, this.pos.y);
                rotate(frameCount * 0.02);
                noFill();
                for(let i=0; i<5; i++) {
                    strokeWeight(random(2,5));
                    stroke(255, 100, 50, random(50, 150)); // 주황/붉은 빛
                    let diskSize = this.size * 1.5 + random(-10, 10);
                    arc(0, 0, diskSize, diskSize, random(TWO_PI), random(TWO_PI));
                }
                pop();

                // 블랙홀 본체 (사건의 지평선)
                noStroke();
                fill(0); // 완전 검은색
                ellipse(this.pos.x, this.pos.y, this.size);
                // 약간의 빛 번짐
                fill(0,0,0, 50);
                ellipse(this.pos.x, this.pos.y, this.size + 10);
            }
        }

        // --- 행성 클래스 ---
        class Planet {
            constructor(x, y, size, color, speedX) {
                this.pos = createVector(x, y);
                this.size = size;
                this.color = color;
                this.velX = speedX;
            }
            update() {
                this.pos.x += this.velX;
                // 화면 밖 루프
                if(this.pos.x > width + this.size) this.pos.x = -this.size;
            }
            draw() {
                noStroke();
                // 행성 본체
                fill(this.color);
                ellipse(this.pos.x, this.pos.y, this.size);
                // 행성 대기/빛 반사 효과 (간단하게)
                fill(255, 255, 255, 50);
                ellipse(this.pos.x - this.size*0.1, this.pos.y - this.size*0.1, this.size*0.8);
            }
        }

        // --- 기존 네트워크 파티클 클래스 (수정 없음) ---
        class Particle {
            constructor() {
                this.pos = createVector(random(width), random(height));
                this.vel = createVector(random(-1, 1), random(-1, 1));
                this.size = random(1, 3);
                this.colors = [color(148, 0, 211, 200), color(75, 0, 130, 200), color(0, 0, 255, 200), color(255, 20, 147, 200)];
                this.color = random(this.colors);
            }
            update() {
                this.pos.add(this.vel);
                if (this.pos.x < 0) this.pos.x = width;
                if (this.pos.x > width) this.pos.x = 0;
                if (this.pos.y < 0) this.pos.y = height;
                if (this.pos.y > height) this.pos.y = 0;
                let mouse = createVector(mouseX, mouseY);
                let dir = p5.Vector.sub(mouse, this.pos);
                if (dir.mag() < 150) {
                    dir.setMag(0.2);
                    this.vel.sub(dir);
                }
                this.vel.limit(2);
            }
            draw() {
                noStroke();
                fill(this.color);
                ellipse(this.pos.x, this.pos.y, this.size);
            }
            connect(others) {
                for (let other of others) {
                    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
                    if (d < 120) {
                        let alpha = map(d, 0, 120, 200, 0);
                        stroke(red(this.color), green(this.color), blue(this.color), alpha);
                        strokeWeight(0.5);
                        line(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
                    }
                }
            }
        }
    </script>
</body>
</html>
